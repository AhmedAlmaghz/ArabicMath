

<think>

Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù… ÙŠØ³Ø£Ù„ Ø¹Ù…Ø§ Ø¥Ø°Ø§ ÙƒØ§Ù†Øª Ø§Ù„Ù…Ù„ÙØ§Øª Ø§Ù„ØªÙŠ Ù‚Ø¯Ù…ØªÙ‡Ø§ ØªÙ…Ø«Ù„ ÙƒÙ„ Ø§Ù„Ù…Ù„ÙØ§Øª Ø§Ù„Ù…Ø·Ù„ÙˆØ¨Ø© Ù„Ù„Ù…Ø´Ø±ÙˆØ¹ Ø£Ù… Ø£Ù† Ù‡Ù†Ø§Ùƒ Ù…Ù„ÙØ§Øª Ø£Ø®Ø±Ù‰. Ø¯Ø¹Ù†ÙŠ Ø£Ø±Ø§Ø¬Ø¹ Ù…Ø§ Ù‚Ø¯Ù…ØªÙ‡ ÙˆØ£Ø±Ù‰ Ù…Ø§ Ù‡Ùˆ Ù…ÙÙ‚ÙˆØ¯ Ù„Ø¥Ù†Ø´Ø§Ø¡ Ù…ÙƒØªØ¨Ø© Ù…ØªÙƒØ§Ù…Ù„Ø©:

Ù…Ø§ Ù‚Ø¯Ù…ØªÙ‡:
1. ArabicMath.js (Ø§Ù„Ù…Ù„Ù Ø§Ù„Ø£Ø³Ø§Ø³ÙŠ)
2. translator.js (Ù…Ø­Ø±Ùƒ Ø§Ù„ØªØ±Ø¬Ù…Ø©) 
3. dictionaries/symbols.js (Ø§Ù„Ù‚ÙˆØ§Ù…ÙŠØ³)
4. arabic-math.css (Ø§Ù„Ø£Ù†Ù…Ø§Ø·)
5. example.html (Ù…Ø«Ø§Ù„ Ù„Ù„Ø§Ø³ØªØ®Ø¯Ø§Ù…)
6. build.js (Ù…Ù„Ù Ø§Ù„Ø¨Ù†Ø§Ø¡)
7. README.md (Ø§Ù„ØªÙˆØ«ÙŠÙ‚)

Ù…Ø§ Ù‡Ùˆ Ù…ÙÙ‚ÙˆØ¯:
1. parser.js - Ø°ÙƒØ±ØªÙ‡ ÙÙŠ Ø§Ù„Ù‡ÙŠÙƒÙ„ Ù„ÙƒÙ† Ù„Ù… Ø£Ù‚Ø¯Ù… Ø§Ù„ÙƒÙˆØ¯
2. renderer.js - Ø°ÙƒØ±ØªÙ‡ Ø£ÙŠØ¶Ø§Ù‹ Ù„ÙƒÙ† Ù„Ù… Ø£Ù‚Ø¯Ù… Ø§Ù„ÙƒÙˆØ¯
3. utils/rtl-handler.js - Ø°ÙƒØ±ØªÙ‡ Ù„ÙƒÙ† Ù„Ù… Ø£Ù‚Ø¯Ù… Ø§Ù„ÙƒÙˆØ¯
4. utils/validator.js - Ø°ÙƒØ±ØªÙ‡ Ù„ÙƒÙ† Ù„Ù… Ø£Ù‚Ø¯Ù… Ø§Ù„ÙƒÙˆØ¯
5. Ù…Ù„ÙØ§Øª Ø§Ù„Ø§Ø®ØªØ¨Ø§Ø± ÙÙŠ Ù…Ø¬Ù„Ø¯ tests/
6. Ù…Ù„ÙØ§Øª Ø§Ù„ØªÙˆØ«ÙŠÙ‚ Ø§Ù„Ø¥Ø¶Ø§ÙÙŠØ© ÙÙŠ docs/
7. Ù…Ù„ÙØ§Øª Ø§Ù„ØªÙƒÙˆÙŠÙ† Ù…Ø«Ù„ .gitignore, package.json Ù„Ù„ØªØ·ÙˆÙŠØ±
8. webpack.config.js Ø£Ùˆ rollup.config.js Ù„Ù„Ø¨Ù†Ø§Ø¡ Ø§Ù„Ù…ØªÙ‚Ø¯Ù…
9. TypeScript definitions Ø¥Ø°Ø§ ÙƒØ§Ù† Ø§Ù„Ù…Ø´Ø±ÙˆØ¹ ÙŠØ¯Ø¹Ù… TypeScript


10. Ù…Ù„ÙØ§Øª Ø§Ù„Ø®Ø·ÙˆØ· Ø§Ù„Ø¹Ø±Ø¨ÙŠØ©
11. Ù…Ù„ÙØ§Øª Ø£Ù…Ø«Ù„Ø© Ø¥Ø¶Ø§ÙÙŠØ©
12. Ù…Ù„Ù LICENSE
13. CHANGELOG.md
14. CONTRIBUTING.md

Ø£ÙƒÙ…Ù„ Ù‚Ø§Ø¦Ù…Ø© Ø§Ù„Ù…Ù„ÙØ§Øª Ø§Ù„Ø¶Ø±ÙˆØ±ÙŠØ© Ù„Ù„Ù…Ø´Ø±ÙˆØ¹ØŒ Ù…Ø¹ Ø§Ù„ØªØ±ÙƒÙŠØ² Ø¹Ù„Ù‰ Ø§Ù„ÙˆØ«Ø§Ø¦Ù‚ ÙˆØ§Ù„Ù…ÙˆØ§Ø±Ø¯ Ø§Ù„Ø¥Ø¶Ø§ÙÙŠØ© Ø§Ù„ØªÙŠ Ø³ØªØ¬Ø¹Ù„ Ø§Ù„Ù…ÙƒØªØ¨Ø© Ø£ÙƒØ«Ø± Ø§Ø­ØªØ±Ø§ÙÙŠØ© ÙˆØ³Ù‡ÙˆÙ„Ø© ÙÙŠ Ø§Ù„Ø§Ø³ØªØ®Ø¯Ø§Ù…. Ø³Ø£Ø¶ÙŠÙ Ø¨Ø¹Ø¶ Ø§Ù„Ù…Ù„ÙØ§Øª Ø§Ù„ØªÙƒÙ…ÙŠÙ„ÙŠØ© Ù„Ø¶Ù…Ø§Ù† Ø¬ÙˆØ¯Ø© ÙˆØ´Ù…ÙˆÙ„ÙŠØ© Ø§Ù„Ù…Ø´Ø±ÙˆØ¹.

</think>

Ù„Ø§ØŒ Ù‡Ù†Ø§Ùƒ Ø¹Ø¯Ø© Ù…Ù„ÙØ§Øª Ù…Ù‡Ù…Ø© Ø£Ø®Ø±Ù‰ Ù„Ù… Ø£Ù‚Ø¯Ù…Ù‡Ø§ Ø¨Ø¹Ø¯ Ù„Ø¥ÙƒÙ…Ø§Ù„ Ø§Ù„Ù…Ø´Ø±ÙˆØ¹. Ø¥Ù„ÙŠÙƒ **Ø§Ù„Ø¨Ù†ÙŠØ© Ø§Ù„ÙƒØ§Ù…Ù„Ø©** Ù„Ù„Ù…Ø´Ø±ÙˆØ¹:

## ğŸ“ **Ø§Ù„Ø¨Ù†ÙŠØ© Ø§Ù„ÙƒØ§Ù…Ù„Ø© Ù„Ù„Ù…Ø´Ø±ÙˆØ¹**

```
ArabicMathJS/
â”œâ”€â”€ ğŸ“ src/
â”‚   â”œâ”€â”€ ğŸ“ core/
â”‚   â”‚   â”œâ”€â”€ ğŸ“„ ArabicMath.js          âœ… (Ù‚Ø¯Ù…ØªÙ‡)
â”‚   â”‚   â”œâ”€â”€ ğŸ“„ translator.js         âœ… (Ù‚Ø¯Ù…ØªÙ‡) 
â”‚   â”‚   â”œâ”€â”€ ğŸ“„ parser.js            âŒ (Ù…ÙÙ‚ÙˆØ¯)
â”‚   â”‚   â”œâ”€â”€ ğŸ“„ renderer.js          âŒ (Ù…ÙÙ‚ÙˆØ¯)
â”‚   â”‚   â””â”€â”€ ğŸ“„ validator.js         âŒ (Ù…ÙÙ‚ÙˆØ¯)
â”‚   â”œâ”€â”€ ğŸ“ dictionaries/
â”‚   â”‚   â”œâ”€â”€ ğŸ“„ symbols.js           âœ… (Ù‚Ø¯Ù…ØªÙ‡)
â”‚   â”‚   â”œâ”€â”€ ğŸ“„ functions.js         âŒ (Ø¬Ø²Ø¡ Ù…Ù†Ù‡ ÙÙ‚Ø·)
â”‚   â”‚   â”œâ”€â”€ ğŸ“„ operations.js        âŒ (Ø¬Ø²Ø¡ Ù…Ù†Ù‡ ÙÙ‚Ø·)
â”‚   â”‚   â”œâ”€â”€ ğŸ“„ compounds.js         âŒ (Ù…ÙÙ‚ÙˆØ¯)
â”‚   â”‚   â””â”€â”€ ğŸ“„ arabic-terms.js      âŒ (Ù…ÙÙ‚ÙˆØ¯)
â”‚   â”œâ”€â”€ ğŸ“ utils/
â”‚   â”‚   â”œâ”€â”€ ğŸ“„ rtl-handler.js       âŒ (Ù…ÙÙ‚ÙˆØ¯)
â”‚   â”‚   â”œâ”€â”€ ğŸ“„ math-utils.js        âŒ (Ù…ÙÙ‚ÙˆØ¯)
â”‚   â”‚   â””â”€â”€ ğŸ“„ string-utils.js      âŒ (Ù…ÙÙ‚ÙˆØ¯)
â”‚   â”œâ”€â”€ ğŸ“ styles/
â”‚   â”‚   â”œâ”€â”€ ğŸ“„ arabic-math.css      âœ… (Ù‚Ø¯Ù…ØªÙ‡)
â”‚   â”‚   â”œâ”€â”€ ğŸ“„ themes.css           âŒ (Ù…ÙÙ‚ÙˆØ¯)
â”‚   â”‚   â””â”€â”€ ğŸ“ fonts/               âŒ (Ù…ÙÙ‚ÙˆØ¯)
â”‚   â”‚       â”œâ”€â”€ ğŸ“„ amiri-math.woff2
â”‚   â”‚       â””â”€â”€ ğŸ“„ arabic-math.woff2
â”‚   â””â”€â”€ ğŸ“„ index.js                 âŒ (Ù…ÙÙ‚ÙˆØ¯)
â”œâ”€â”€ ğŸ“ dist/                        âœ… (ÙŠÙÙ†Ø´Ø£ Ø¨Ø§Ù„Ø¨Ù†Ø§Ø¡)
â”œâ”€â”€ ğŸ“ examples/
â”‚   â”œâ”€â”€ ğŸ“„ basic-usage.html         âŒ (Ù…ÙÙ‚ÙˆØ¯)
â”‚   â”œâ”€â”€ ğŸ“„ advanced-examples.html   âœ… (example.html Ù‚Ø¯Ù…ØªÙ‡)
â”‚   â”œâ”€â”€ ğŸ“„ interactive-demo.html    âŒ (Ù…ÙÙ‚ÙˆØ¯)
â”‚   â””â”€â”€ ğŸ“„ integration-examples.js  âŒ (Ù…ÙÙ‚ÙˆØ¯)
â”œâ”€â”€ ğŸ“ tests/
â”‚   â”œâ”€â”€ ğŸ“„ translator.test.js       âŒ (Ù…ÙÙ‚ÙˆØ¯)
â”‚   â”œâ”€â”€ ğŸ“„ parser.test.js           âŒ (Ù…ÙÙ‚ÙˆØ¯)
â”‚   â”œâ”€â”€ ğŸ“„ integration.test.js      âŒ (Ù…ÙÙ‚ÙˆØ¯)
â”‚   â””â”€â”€ ğŸ“„ test-runner.html         âŒ (Ù…ÙÙ‚ÙˆØ¯)
â”œâ”€â”€ ğŸ“ docs/
â”‚   â”œâ”€â”€ ğŸ“„ api-reference.md         âŒ (Ù…ÙÙ‚ÙˆØ¯)
â”‚   â”œâ”€â”€ ğŸ“„ examples.md              âŒ (Ù…ÙÙ‚ÙˆØ¯)
â”‚   â”œâ”€â”€ ğŸ“„ customization.md         âŒ (Ù…ÙÙ‚ÙˆØ¯)
â”‚   â””â”€â”€ ğŸ“„ contributing.md          âŒ (Ù…ÙÙ‚ÙˆØ¯)
â”œâ”€â”€ ğŸ“ tools/
â”‚   â”œâ”€â”€ ğŸ“„ build.js                 âœ… (Ù‚Ø¯Ù…ØªÙ‡)
â”‚   â”œâ”€â”€ ğŸ“„ webpack.config.js        âŒ (Ù…ÙÙ‚ÙˆØ¯)
â”‚   â””â”€â”€ ğŸ“„ serve.js                 âŒ (Ù…ÙÙ‚ÙˆØ¯)
â”œâ”€â”€ ğŸ“„ package.json                 âŒ (Ø°ÙƒØ±ØªÙ‡ ÙÙŠ build.js Ù„ÙƒÙ† Ù„Ù… Ø£Ù†Ø´Ø¦Ù‡)
â”œâ”€â”€ ğŸ“„ README.md                    âœ… (Ù‚Ø¯Ù…ØªÙ‡)
â”œâ”€â”€ ğŸ“„ LICENSE                      âŒ (Ù…ÙÙ‚ÙˆØ¯)
â”œâ”€â”€ ğŸ“„ CHANGELOG.md                 âŒ (Ù…ÙÙ‚ÙˆØ¯)
â”œâ”€â”€ ğŸ“„ .gitignore                   âŒ (Ù…ÙÙ‚ÙˆØ¯)
â”œâ”€â”€ ğŸ“„ .npmignore                   âŒ (Ù…ÙÙ‚ÙˆØ¯)
â””â”€â”€ ğŸ“„ index.d.ts                   âŒ (Ù…ÙÙ‚ÙˆØ¯ - TypeScript definitions)
```

## ğŸ“ **Ø§Ù„Ù…Ù„ÙØ§Øª Ø§Ù„Ù…ÙÙ‚ÙˆØ¯Ø© Ø§Ù„Ù…Ù‡Ù…Ø©**

### **1. parser.js - Ù…Ø­Ù„Ù„ Ø§Ù„Ù…Ø¹Ø§Ø¯Ù„Ø§Øª**

```javascript
/**
 * Ù…Ø­Ù„Ù„ Ø§Ù„Ù…Ø¹Ø§Ø¯Ù„Ø§Øª Ø§Ù„Ø±ÙŠØ§Ø¶ÙŠØ©
 * ÙŠØ­ÙˆÙ„ Ø§Ù„Ù†Øµ Ø¥Ù„Ù‰ Ù‡ÙŠÙƒÙ„ Ø¨ÙŠØ§Ù†Ø§Øª Ù‚Ø§Ø¨Ù„ Ù„Ù„Ù…Ø¹Ø§Ù„Ø¬Ø©
 */
class MathParser {
    constructor() {
        this.tokenTypes = {
            FUNCTION: 'function',
            VARIABLE: 'variable',
            NUMBER: 'number',
            OPERATOR: 'operator',
            SYMBOL: 'symbol',
            BRACKET: 'bracket',
            LATEX_COMMAND: 'latex_command'
        };
    }
    
    /**
     * ØªØ­Ù„ÙŠÙ„ Ø§Ù„Ù…Ø¹Ø§Ø¯Ù„Ø© Ø§Ù„Ø±ÙŠØ§Ø¶ÙŠØ©
     * @param {string} input - Ø§Ù„Ù†Øµ Ø§Ù„Ù…Ø¯Ø®Ù„
     * @returns {Array} Ù…ØµÙÙˆÙØ© Ù…Ù† Ø§Ù„Ø±Ù…ÙˆØ² Ø§Ù„Ù…Ø­Ù„Ù„Ø©
     */
    parse(input) {
        // ØªÙ†Ø¸ÙŠÙ Ø§Ù„Ù†Øµ Ø§Ù„Ù…Ø¯Ø®Ù„
        const cleaned = this.preprocess(input);
        
        // ØªÙ‚Ø³ÙŠÙ… Ø¥Ù„Ù‰ Ø±Ù…ÙˆØ²
        const tokens = this.tokenize(cleaned);
        
        // ØªØ­Ù„ÙŠÙ„ ØªØ±ÙƒÙŠØ¨ÙŠ
        const ast = this.buildAST(tokens);
        
        return ast;
    }
    
    preprocess(input) {
        return input
            .replace(/\s+/g, ' ')           // ØªÙˆØ­ÙŠØ¯ Ø§Ù„Ù…Ø³Ø§ÙØ§Øª
            .replace(/\\,/g, ' ')           // Ù…Ø³Ø§ÙØ§Øª LaTeX
            .replace(/\\!/g, '')            // Ø¥Ø²Ø§Ù„Ø© Ø§Ù„Ù…Ø³Ø§ÙØ§Øª Ø§Ù„Ø³Ø§Ù„Ø¨Ø©
            .trim();
    }
    
    tokenize(input) {
        const tokens = [];
        const patterns = [
            { type: this.tokenTypes.LATEX_COMMAND, regex: /\\[a-zA-Z]+\*?/g },
            { type: this.tokenTypes.FUNCTION, regex: /\b(sin|cos|tan|log|ln|exp|sqrt|lim|sum|prod|int)\b/g },
            { type: this.tokenTypes.NUMBER, regex: /\d+\.?\d*/g },
            { type: this.tokenTypes.VARIABLE, regex: /\b[a-zA-Z]\b/g },
            { type: this.tokenTypes.OPERATOR, regex: /[+\-*/=<>â‰¤â‰¥â‰ â‰ˆ]/g },
            { type: this.tokenTypes.SYMBOL, regex: /[âˆ«âˆ‘âˆâˆšâˆÏ€âˆ‚âˆ‡]/g },
            { type: this.tokenTypes.BRACKET, regex: /[(){}\[\]]/g }
        ];
        
        let position = 0;
        while (position < input.length) {
            let matched = false;
            
            for (const pattern of patterns) {
                pattern.regex.lastIndex = position;
                const match = pattern.regex.exec(input);
                
                if (match && match.index === position) {
                    tokens.push({
                        type: pattern.type,
                        value: match[0],
                        position: position
                    });
                    position = match.index + match[0].length;
                    matched = true;
                    break;
                }
            }
            
            if (!matched) {
                position++;
            }
        }
        
        return tokens;
    }
    
    buildAST(tokens) {
        // Ø¨Ù†Ø§Ø¡ Ø´Ø¬Ø±Ø© Ø§Ù„ØªØ­Ù„ÙŠÙ„ Ø§Ù„ØªØ±ÙƒÙŠØ¨ÙŠ
        // Ù‡Ø°Ø§ Ù…Ø¨Ø³Ø· - ÙÙŠ Ø§Ù„ØªØ·Ø¨ÙŠÙ‚ Ø§Ù„Ø­Ù‚ÙŠÙ‚ÙŠ Ù†Ø­ØªØ§Ø¬ parser Ø£Ø¹Ù‚Ø¯
        return {
            type: 'expression',
            tokens: tokens,
            structure: this.analyzeStructure(tokens)
        };
    }
    
    analyzeStructure(tokens) {
        const structure = {
            functions: [],
            variables: [],
            operators: [],
            commands: []
        };
        
        tokens.forEach(token => {
            switch (token.type) {
                case this.tokenTypes.FUNCTION:
                    structure.functions.push(token);
                    break;
                case this.tokenTypes.VARIABLE:
                    structure.variables.push(token);
                    break;
                case this.tokenTypes.OPERATOR:
                    structure.operators.push(token);
                    break;
                case this.tokenTypes.LATEX_COMMAND:
                    structure.commands.push(token);
                    break;
            }
        });
        
        return structure;
    }
}
```

### **2. renderer.js - Ù…Ø­Ø±Ùƒ Ø§Ù„Ø¹Ø±Ø¶**

```javascript
/**
 * Ù…Ø­Ø±Ùƒ Ø¹Ø±Ø¶ Ø§Ù„Ù…Ø¹Ø§Ø¯Ù„Ø§Øª Ø§Ù„Ø±ÙŠØ§Ø¶ÙŠØ©
 * ÙŠØªØ¹Ø§Ù…Ù„ Ù…Ø¹ MathJax Ùˆ KaTeX
 */
class MathRenderer {
    constructor(options = {}) {
        this.options = {
            engine: 'mathjax', // Ø£Ùˆ 'katex'
            displayMode: 'auto',
            rtl: true,
            ...options
        };
        
        this.isReady = false;
        this.queue = [];
    }
    
    /**
     * Ø¹Ø±Ø¶ Ù…Ø¹Ø§Ø¯Ù„Ø© ÙÙŠ Ø¹Ù†ØµØ± HTML
     * @param {HTMLElement} element - Ø§Ù„Ø¹Ù†ØµØ± Ø§Ù„Ù…Ø³ØªÙ‡Ø¯Ù
     * @param {string} equation - Ø§Ù„Ù…Ø¹Ø§Ø¯Ù„Ø© Ø§Ù„Ù…ØªØ±Ø¬Ù…Ø©
     * @param {object} options - Ø®ÙŠØ§Ø±Ø§Øª Ø§Ù„Ø¹Ø±Ø¶
     */
    async render(element, equation, options = {}) {
        const renderOptions = { ...this.options, ...options };
        
        // Ø¥Ø¹Ø¯Ø§Ø¯ Ø§Ù„Ø¹Ù†ØµØ± Ù„Ù„Ø¹Ø±Ø¶ Ø§Ù„Ø¹Ø±Ø¨ÙŠ
        this.prepareElement(element, renderOptions);
        
        // Ø§Ø®ØªÙŠØ§Ø± Ù…Ø­Ø±Ùƒ Ø§Ù„Ø¹Ø±Ø¶
        if (renderOptions.engine === 'mathjax') {
            await this.renderWithMathJax(element, equation, renderOptions);
        } else if (renderOptions.engine === 'katex') {
            await this.renderWithKaTeX(element, equation, renderOptions);
        }
        
        // Ù…Ø¹Ø§Ù„Ø¬Ø© RTL Ø¨Ø¹Ø¯ Ø§Ù„Ø¹Ø±Ø¶
        this.postProcessRTL(element, renderOptions);
    }
    
    prepareElement(element, options) {
        // Ø¥Ø¶Ø§ÙØ© ÙƒÙ„Ø§Ø³Ø§Øª CSS
        element.classList.add('arabic-math');
        if (options.rtl) {
            element.classList.add('rtl');
            element.dir = 'rtl';
        }
        
        // ØªØ­Ø¯ÙŠØ¯ Ù†ÙˆØ¹ Ø§Ù„Ø¹Ø±Ø¶
        const displayMode = this.detectDisplayMode(element, options);
        if (displayMode === 'block') {
            element.classList.add('math-display');
        } else {
            element.classList.add('math-inline');
        }
    }
    
    async renderWithMathJax(element, equation, options) {
        if (typeof MathJax === 'undefined') {
            throw new Error('MathJax ØºÙŠØ± Ù…Ø­Ù…Ù„');
        }
        
        // ØªØ­Ø¯ÙŠØ¯ ØµÙŠØºØ© Ø§Ù„Ù…Ø¹Ø§Ø¯Ù„Ø©
        const mathML = options.displayMode === 'block' 
            ? `\\[${equation}\\]`
            : `\\(${equation}\\)`;
        
        // Ø¥Ø¯Ø±Ø§Ø¬ Ø§Ù„Ù…Ø¹Ø§Ø¯Ù„Ø©
        element.innerHTML = mathML;
        
        // Ù…Ø¹Ø§Ù„Ø¬Ø© Ø¨ÙˆØ§Ø³Ø·Ø© MathJax
        try {
            await MathJax.typesetPromise([element]);
        } catch (error) {
            console.error('Ø®Ø·Ø£ ÙÙŠ Ø¹Ø±Ø¶ MathJax:', error);
            element.innerHTML = `<span class="math-error">Ø®Ø·Ø£ ÙÙŠ Ø§Ù„Ø¹Ø±Ø¶: ${equation}</span>`;
        }
    }
    
    async renderWithKaTeX(element, equation, options) {
        if (typeof katex === 'undefined') {
            throw new Error('KaTeX ØºÙŠØ± Ù…Ø­Ù…Ù„');
        }
        
        try {
            katex.render(equation, element, {
                displayMode: options.displayMode === 'block',
                throwOnError: false,
                errorColor: '#cc0000',
                trust: true
            });
        } catch (error) {
            console.error('Ø®Ø·Ø£ ÙÙŠ Ø¹Ø±Ø¶ KaTeX:', error);
            element.innerHTML = `<span class="math-error">Ø®Ø·Ø£ ÙÙŠ Ø§Ù„Ø¹Ø±Ø¶: ${equation}</span>`;
        }
    }
    
    detectDisplayMode(element, options) {
        if (options.displayMode !== 'auto') {
            return options.displayMode;
        }
        
        // ØªØ­Ø¯ÙŠØ¯ ØªÙ„Ù‚Ø§Ø¦ÙŠ Ø¨Ù†Ø§Ø¡ Ø¹Ù„Ù‰ Ø§Ù„Ø³ÙŠØ§Ù‚
        const parent = element.parentElement;
        const isBlock = window.getComputedStyle(parent).display === 'block';
        const hasDisplayClass = element.classList.contains('math-display');
        
        return (isBlock || hasDisplayClass) ? 'block' : 'inline';
    }
    
    postProcessRTL(element, options) {
        if (!options.rtl) return;
        
        // Ù…Ø¹Ø§Ù„Ø¬Ø© Ø®Ø§ØµØ© Ù„Ù„Ø¹Ù†Ø§ØµØ± Ø§Ù„ØªÙŠ ØªØ­ØªØ§Ø¬ Ø¥Ø¹Ø§Ø¯Ø© ØªØ±ØªÙŠØ¨
        const arrows = element.querySelectorAll('.MathJax [data-char]');
        arrows.forEach(arrow => {
            const char = arrow.getAttribute('data-char');
            if (char === 'â†’') {
                arrow.setAttribute('data-char', 'â†');
                arrow.textContent = 'â†';
            }
        });
    }
}
```

### **3. rtl-handler.js - Ù…Ø¹Ø§Ù„Ø¬ Ø§Ù„Ø§ØªØ¬Ø§Ù‡**

```javascript
/**
 * Ù…Ø¹Ø§Ù„Ø¬ Ø§Ù„ÙƒØªØ§Ø¨Ø© Ù…Ù† Ø§Ù„ÙŠÙ…ÙŠÙ† Ø¥Ù„Ù‰ Ø§Ù„ÙŠØ³Ø§Ø±
 * ÙŠØªØ¹Ø§Ù…Ù„ Ù…Ø¹ ØªØ¹Ù‚ÙŠØ¯Ø§Øª RTL ÙÙŠ Ø§Ù„Ù…Ø¹Ø§Ø¯Ù„Ø§Øª Ø§Ù„Ø±ÙŠØ§Ø¶ÙŠØ©
 */
class RTLHandler {
    constructor() {
        this.rtlPatterns = {
            // Ø§Ù„Ø£Ø³Ù‡Ù… Ø§Ù„ØªÙŠ ØªØ­ØªØ§Ø¬ Ù‚Ù„Ø¨
            arrows: [
                { from: 'â†’', to: 'â†' },
                { from: 'â†', to: 'â†’' },
                { from: 'âŸ¹', to: 'âŸ¸' },
                { from: 'âŸ¸', to: 'âŸ¹' },
                { from: 'â†¦', to: 'â†¤' },
                { from: 'â†¤', to: 'â†¦' }
            ],
            
            // Ø§Ù„Ø£Ù‚ÙˆØ§Ø³ Ø§Ù„ØªÙŠ ØªØ­ØªØ§Ø¬ Ù‚Ù„Ø¨
            brackets: [
                { from: '(', to: ')' },
                { from: ')', to: '(' },
                { from: '[', to: ']' },
                { from: ']', to: '[' },
                { from: '{', to: '}' },
                { from: '}', to: '{' }
            ]
        };
    }
    
    /**
     * Ù…Ø¹Ø§Ù„Ø¬Ø© Ù…Ø¹Ø§Ø¯Ù„Ø© Ù„Ù„ÙƒØªØ§Ø¨Ø© Ù…Ù† Ø§Ù„ÙŠÙ…ÙŠÙ† Ø¥Ù„Ù‰ Ø§Ù„ÙŠØ³Ø§Ø±
     * @param {string} equation - Ø§Ù„Ù…Ø¹Ø§Ø¯Ù„Ø©
     * @param {object} options - Ø®ÙŠØ§Ø±Ø§Øª Ø§Ù„Ù…Ø¹Ø§Ù„Ø¬Ø©
     * @returns {string} Ø§Ù„Ù…Ø¹Ø§Ø¯Ù„Ø© Ù…Ø¹Ø¯Ù„Ø© Ù„Ù„Ù€ RTL
     */
    processRTL(equation, options = {}) {
        let result = equation;
        
        // Ù‚Ù„Ø¨ Ø§Ù„Ø£Ø³Ù‡Ù…
        if (options.flipArrows !== false) {
            result = this.flipArrows(result);
        }
        
        // Ù…Ø¹Ø§Ù„Ø¬Ø© Ø­Ø¯ÙˆØ¯ Ø§Ù„ØªÙƒØ§Ù…Ù„ ÙˆØ§Ù„Ù…Ø¬Ø§Ù…ÙŠØ¹
        if (options.swapBounds !== false) {
            result = this.swapIntegralBounds(result);
            result = this.swapSumBounds(result);
        }
        
        // Ù…Ø¹Ø§Ù„Ø¬Ø© Ø§Ù„ÙƒØ³ÙˆØ±
        if (options.handleFractions !== false) {
            result = this.processFractions(result);
        }
        
        // Ù…Ø¹Ø§Ù„Ø¬Ø© Ø§Ù„Ù…ØµÙÙˆÙØ§Øª
        if (options.handleMatrices !== false) {
            result = this.processMatrices(result);
        }
        
        return result;
    }
    
    flipArrows(equation) {
        let result = equation;
        this.rtlPatterns.arrows.forEach(arrow => {
            result = result.replace(new RegExp(arrow.from, 'g'), arrow.to);
        });
        return result;
    }
    
    swapIntegralBounds(equation) {
        // ØªØ¨Ø¯ÙŠÙ„ Ø­Ø¯ÙˆØ¯ Ø§Ù„ØªÙƒØ§Ù…Ù„ Ù…Ù† âˆ«_a^b Ø¥Ù„Ù‰ âˆ«^b_a
        return equation.replace(
            /\\int_\{([^}]+)\}\^\{([^}]+)\}/g,
            '\\int^{$2}_{$1}'
        ).replace(
            /âˆ«_\{([^}]+)\}\^\{([^}]+)\}/g,
            'âˆ«^{$2}_{$1}'
        );
    }
    
    swapSumBounds(equation) {
        // ØªØ¨Ø¯ÙŠÙ„ Ø­Ø¯ÙˆØ¯ Ø§Ù„Ù…Ø¬Ø§Ù…ÙŠØ¹
        return equation.replace(
            /\\sum_\{([^}]+)\}\^\{([^}]+)\}/g,
            '\\sum^{$2}_{$1}'
        ).replace(
            /âˆ‘_\{([^}]+)\}\^\{([^}]+)\}/g,
            'âˆ‘^{$2}_{$1}'
        );
    }
    
    processFractions(equation) {
        // ÙÙŠ Ù…Ø¹Ø¸Ù… Ø§Ù„Ø­Ø§Ù„Ø§ØªØŒ Ø§Ù„ÙƒØ³ÙˆØ± Ù„Ø§ ØªØ­ØªØ§Ø¬ ØªØ¹Ø¯ÙŠÙ„ Ø®Ø§Øµ
        // Ù„ÙƒÙ† ÙŠÙ…ÙƒÙ† Ø¥Ø¶Ø§ÙØ© Ù…Ø¹Ø§Ù„Ø¬Ø© Ø®Ø§ØµØ© Ø¥Ø°Ø§ Ù„Ø²Ù… Ø§Ù„Ø£Ù…Ø±
        return equation;
    }
    
    processMatrices(equation) {
        // Ù…Ø¹Ø§Ù„Ø¬Ø© Ø§Ù„Ù…ØµÙÙˆÙØ§Øª Ù„Ù„Ø¹Ø±Ø¶ Ø§Ù„ØµØ­ÙŠØ­ ÙÙŠ RTL
        // Ù‡Ø°Ø§ ÙŠØªØ·Ù„Ø¨ ØªØ­Ù„ÙŠÙ„ Ø£Ø¹Ù‚Ø¯ Ù„Ù„Ø¨Ù†ÙŠØ©
        return equation.replace(
            /\\begin\{(pmatrix|bmatrix|vmatrix)\}([\s\S]*?)\\end\{\1\}/g,
            (match, matrixType, content) => {
                // Ù‚Ù„Ø¨ ØªØ±ØªÙŠØ¨ Ø§Ù„Ø£Ø¹Ù…Ø¯Ø© ÙÙŠ Ø§Ù„Ù…ØµÙÙˆÙØ©
                const rows = content.trim().split('\\\\');
                const flippedRows = rows.map(row => {
                    const columns = row.split('&');
                    return columns.reverse().join('&');
                });
                return `\\begin{${matrixType}}${flippedRows.join('\\\\')}\\end{${matrixType}}`;
            }
        );
    }
    
    /**
     * Ù…Ø¹Ø§Ù„Ø¬Ø© Ø¹Ù†ØµØ± HTML Ø¨Ø¹Ø¯ Ø§Ù„Ø¹Ø±Ø¶
     * @param {HTMLElement} element - Ø§Ù„Ø¹Ù†ØµØ± Ø§Ù„Ù…Ø¹Ø±ÙˆØ¶
     */
    postProcessElement(element) {
        // Ø¥Ø¶Ø§ÙØ© Ø®ØµØ§Ø¦Øµ RTL
        element.style.direction = 'rtl';
        element.style.textAlign = 'right';
        
        // Ù…Ø¹Ø§Ù„Ø¬Ø© Ø§Ù„Ø¹Ù†Ø§ØµØ± Ø§Ù„ÙØ±Ø¹ÙŠØ©
        const mathElements = element.querySelectorAll('.MathJax, .katex');
        mathElements.forEach(mathEl => {
            mathEl.style.direction = 'ltr'; // Ø§Ù„Ø±ÙŠØ§Ø¶ÙŠØ§Øª ØªØ­ØªØ§Ø¬ LTR Ø¯Ø§Ø®Ù„ÙŠÙ‹Ø§
            mathEl.parentElement.style.direction = 'rtl'; // Ù„ÙƒÙ† Ø§Ù„Ø­Ø§ÙˆÙŠ RTL
        });
    }
}
```

### **4. Ù…Ù„ÙØ§Øª Ø§Ù„ØªÙƒÙˆÙŠÙ† ÙˆØ§Ù„Ø¨Ù†Ø§Ø¡**

**package.json:**
```json
{
  "name": "arabic-math-js",
  "version": "1.0.0",
  "description": "Ù…ÙƒØªØ¨Ø© Ø¬Ø§ÙØ§ Ø³ÙƒØ±ÙŠØ¨Øª Ù…ØªÙ‚Ø¯Ù…Ø© Ù„ØªØ±Ø¬Ù…Ø© ÙˆØ¹Ø±Ø¶ Ø§Ù„Ù…Ø¹Ø§Ø¯Ù„Ø§Øª Ø§Ù„Ø±ÙŠØ§Ø¶ÙŠØ© Ø¨Ø§Ù„Ù„ØºØ© Ø§Ù„Ø¹Ø±Ø¨ÙŠØ©",
  "main": "dist/arabic-math.js",
  "module": "dist/arabic-math.esm.js",
  "types": "dist/index.d.ts",
  "files": [
    "dist/",
    "src/"
  ],
  "scripts": {
    "build": "node tools/build.js",
    "dev": "node tools/serve.js",
    "test": "jest",
    "lint": "eslint src/",
    "docs": "jsdoc src/ -d docs/"
  },
  "keywords": [
    "arabic", "math", "mathematics", "rtl", "latex", "mathjax", "katex", "equations"
  ],
  "author": "Your Name <your.email@example.com>",
  "license": "MIT",
  "repository": {
    "type": "git",
    "url": "https://github.com/username/arabic-math-js.git"
  },
  "dependencies": {},
  "devDependencies": {
    "jest": "^29.0.0",
    "eslint": "^8.0.0",
    "webpack": "^5.0.0",
    "webpack-cli": "^4.0.0",
    "clean-css": "^5.0.0",
    "terser": "^5.0.0"
  },
  "peerDependencies": {
    "mathjax": "^3.0.0"
  }
}
```

**webpack.config.js:**
```javascript
const path = require('path');

module.exports = {
    entry: './src/index.js',
    output: {
        filename: 'arabic-math.min.js',
        path: path.resolve(__dirname, 'dist'),
        library: 'ArabicMath',
        libraryTarget: 'umd'
    },
    module: {
        rules: [
            {
                test: /\.js$/,
                exclude: /node_modules/,
                use: {
                    loader: 'babel-loader',
                    options: {
                        presets: ['@babel/preset-env']
                    }
                }
            },
            {
                test: /\.css$/,
                use: ['style-loader', 'css-loader']
            }
        ]
    },
    optimization: {
        minimize: true
    }
};
```

Ù‡Ù„ ØªØ±ÙŠØ¯ Ù…Ù†ÙŠ ØªÙ‚Ø¯ÙŠÙ… Ø¨Ø§Ù‚ÙŠ Ø§Ù„Ù…Ù„ÙØ§Øª Ø§Ù„Ù…ÙÙ‚ÙˆØ¯Ø© (Ø§Ù„Ø§Ø®ØªØ¨Ø§Ø±Ø§ØªØŒ Ø§Ù„ØªÙˆØ«ÙŠÙ‚ØŒ Ø£Ù…Ø«Ù„Ø© Ø¥Ø¶Ø§ÙÙŠØ©ØŒ Ø¥Ù„Ø®)ØŸ